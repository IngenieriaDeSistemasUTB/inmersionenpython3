
% apendiceA.tex
% This work is licensed under the Creative Commons Attribution-Noncommercial-Share Alike 3.0 License.
% To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/nz
% or send a letter to Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.

\chapter{Migrando código a Python 3 con \codigo{2to3}} \label{ch:migcod}

\noindent Nivel de dificultad:\diflllll

\begin{citaCap}
    ``La vida es agradable. La muerte es tranquilidad. Es la transición lo que es problemático.'' \\
        ---\emph{atribuido a Isaac Asimov}
\end{citaCap}

\section{Inmersión}

 Han cambiado tantas cosas entre Python 2 y Python 3 que son pocos los programas que funcionan con ambos sin modificaciones. ¡Pero no te desalientes! Para ayudar con la transición, Python 3 incorpora una herramienta denomidada \codigo{2to3}, que analiza el código fuente en Python 2 y lo convierte en Python 3 tanto como puede. El capítulo \ref{ch:chardet}, se describe como ejecutar \codigo{2to3}, y muestra algunas cosas que este no puede resolver de forma automática. Este apéndice documenta aquello que sí puede convertir de forma automática.

\section{La sentencia \codigo{print}}

En Python 2, \codigo{print} era una sentencia. Lo que quisieras imprimir iba detrás de ella. En Python 3, \codigo{print()} es una función. Lo quieras imprimir debe pasarse como parámetro, igual que en cualquier otra función.

\begin{table}
  \centering
  \begin{tabular}{ c l l }
  \hline
  Línea & Python 2 & Python 3 \\
  \hline
  1 & \codigo{print}                & \codigo{print()} \\
  2 & \codigo{print 1}              & \codigo{print(1)} \\
  3 & \codigo{print 1, 2}           & \codigo{print(1, 2)} \\
  4 & \codigo{print >{}>sys.stderr, 1, 2, 3} & \codigo{print(1, 2, 3, file=sys.stderr)} \\
  \hline
  \end{tabular}
\end{table}
\FloatBarrier

\begin{enumerate}
  \item \emph{Línea 1:} imprime una línea vacía.
  \item \emph{Línea 2:} imprime un único valor.
  \item \emph{Línea 3:} imprime dos valores separados por espacios.
  \item \emph{Línea 4:} este es un poco complejo. En Python 2, si finalizabas la sentencia \codigo{print} con una coma se imprimían los valores separados por espacios, luego añadía un espacio al final, y paraba sin imprimir un retorno de carro\footnote{Técnicamente, es un poco más complicado. La sentencia \codigo{print} en Python 2 utilizaba un atributo que está ``deprecado'' denominado \codigo{softspace}. En lugar de imprimir un espacio, Python 2 activaba \codigo{sys.stdout.softspace} a 1. El carácter de espacio, no se imprimía hasta que tu aplicación no imprimiera algo más en la misma línea. Si la siguiente sentencia \codigo{print} imprimía un retorno de carro, \codigo{sys.stdout.softspace} pasaría a valer 0 y el espacio nunca se imprimiría. Probablemente nunca te dieras cuenta de la diferencia a menos que tu aplicación fuese sensible a la presencia o ausencia de espacios en blanco al final de las líneas en la salida generada por \codigo{print}.}. En Python 3, la forma de hacer esto es pasar \codigo{end=' '} como un parámetro de la función \codigo{print()}. El parámetro \codigo{end} tiene como valor por defecto \codigo{'\textbackslash n'} (el retorno de carro), por lo que su sustitución elimina el retorno de carro después de imprimir los demás parámetros.

  \item \emph{Línea 5:} en Python 2, puedes redirigir la salida a un flujo diferente de la salida estándar ---como \codigo{sys.stderr}--- mediante el uso de la sintaxis \codigo{>{}>nombre\_de\_flujo}. En Python 3, la forma de hacer esto es pasar el flujo como parámetro \codigo{file}. El valor por defecto de este parámetro es \codigo{sys.stdout} (la salida estándar), por lo que sustituirlo enviará la salida a otro flujo diferente.

\end{enumerate}


\section{Cadenas de caracteres Unicode}

Python 2 tiene dos tipos de cadenas de caracteres: Unicode y no Unicode. Python 3 solo tiene un tipo: Unicode.


\begin{table}
  \centering
  \begin{tabular}{ c l l }
  \hline
  Línea & Python 2 & Python 3 \\
  \hline
  1 & \codigo{u'PapayaWhip'}              & \codigo{'PapayaWhip'} \\
  2 & \codigo{ur'PapayaWhip\textbackslash foo'}             & \codigo{r'PapayaWhip\textbackslash foo'} \\
  \hline
  \end{tabular}
\end{table}
\FloatBarrier

\begin{enumerate}
  \item \emph{Línea 1:} las cadenas de caracteres Unicode se escriben directamente como cadenas de caracteres, que en Python 3 siempre son Unicode.
  \item \emph{Línea 2:} las cadenas de caracteres Unicode Raw (que en Python permiten evitar los caracteres de escape de la barra inclinada invertida) se convierten en cadenas de caracteres Raw, que en Python 3, siempre son Unicode.
\end{enumerate}

\section{La función global \codigo{unicode()}}

Python 2 dispone de dos funciones globales para convertir objetos a cadenas de caracteres: \codigo{unicode()} para convertirlas en cadenas Unicode, y \codigo{str()} para convertirlas en cadenas no Unicode. Python 3 solamente tiene un tipo de cadenas de caracteres, Unicode, por lo que solamente existe la función \codigo{str()}. La función \codigo{unicode()} no existe.

\begin{table}[htp]
  \centering
  \begin{tabular}{c l l}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    & \codigo{unicode(cualquier\_objeto)} & \codigo{str(cualquier\_objeto)} \\
    \hline
  \end{tabular}
\end{table}
\FloatBarrier

\section{El tipo de datos \codigo{long}}

Python 2 tiene dos tipos de datos para números enteros: \codigo{int} y \codigo{long}. Un \codigo{int} no puede ser mayor que \codigo{sys.maxint}, que es diferente según la plataforma. El tipo \codigo{long} se define añadiendo una 'L' al final del número, y puede ser, bueno, más grande que un \codigo{int}.

En Python 3, solamente existe un tipo de números enteros, denominado \codigo{int}, que se comporta como el tipo \codigo{long} de Python 2. Puesto que no existen dos tipos, no hay necesidad de una sintaxis especial para distinguirlos.

Para profundizar, se puede leer el documento \href{http://www.python.org/dev/peps/pep-0237/}{PEP 237: unificando los enteros long e int.}

\begin{table}
  \centering
  \begin{tabular}{c l l }
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1 & \codigo{x = 1000000000000L} & \codigo{x = 1000000000000} \\
    2 & \codigo{x = 0xFFFFFFFFFFFFL} & \codigo{x = 0xFFFFFFFFFFFF} \\
    3 & \codigo{long(x)} & \codigo{int(x)} \\
    4 & \codigo{type(x) is long} & \codigo{type(x) is int} \\
    5 & \codigo{isinstance(x, long)} & \codigo{isinstance(x, int)} \\
    \hline
  \end{tabular}
\end{table}
\FloatBarrier

\begin{enumerate}
  \item \emph{Línea 1:} los enteros largos en base 10 se transforman en enteros en base 10.
  \item \emph{Línea 2:} los enteros largos en base 16 se transforman en enteros en base 16.
  \item \emph{Línea 3:} en Python 3, la función \codigo{long()} desaparece. Para forzar una variable al tipo entero, se utiliza la función \codigo{int()}.
  \item \emph{Línea 4:} la función \codigo{isinstance()} sirve para comprobar el tipo de datos de una variable; de nueveo, se debe utilizar \codigo{int} en lugar de \codigo{long}.
\end{enumerate}

\section{Comparación <{}>}

Python 2 soporta \codigo{<{}>} como sinónimo de \codigo{!=}, el operador de comparación de desigualdad. Python 3 tiene este operador, pero \codigo{<{}>} deja de existir.

\begin{table}[htp]
  \centering
  \begin{tabular}{c l l}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1 & \codigo{if x <{}> y:} & \codigo{if x != y:} \\
    2 & \codigo{if x <{}> y <{}> z:} & \codigo{if x != y != z:} \\
    \hline
  \end{tabular}
\end{table}

\begin{enumerate}
  \item  \emph{Línea 1:} una comparación simple.
  \item  \emph{Línea 2:} una comparación más compleja entre tres valores.
\end{enumerate}

\section{\codigo{Método de diccionarios: has\_key()}}

En Python 2, los diccionarios tienen un método \codigo{has\_key()} para comprobar si el diccionario contiene una determinada clave. En Python 3, este método no existe. En su lugar, debes utilizar el operador \codigo{in}.

\begin{table}[htp]
  \centering
  \begin{tabular}{c l l}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1 & \codigo{un\_diccionario.has\_key('PapayaWhip')}
      & \codigo{'PapayaWhip' in un\_diccionario} \\
      \\
    2 & \pbox{10cm}{\codigo{un\_diccionario.has\_key(x) or} \\ 
                    \codigo{un\_diccionario.has\_key(y)}}
      & \pbox{10cm}{\codigo{x in un\_diccionario or} \\
                    \codigo{y in un\_diccionario}} \\
      \\
    3 & \codigo{un\_diccionario.has\_key(x or y)}
      & \codigo{(x or y) in un\_diccionario} \\
    4 & \codigo{un\_diccionario.has\_key(x + y)}
      & \codigo{(x + y) in un\_diccionario} \\
    5 & \codigo{x + un\_diccionario.has\_key(y)}
      & \codigo{x + (y in un\_diccionario)} \\
    \hline
  \end{tabular}
\end{table}
\FloatBarrier

\begin{enumerate}
  \item \emph{Línea 1:} la forma más simple.
  \item \emph{Línea 2:} el operador \codigo{in} tiene precedencia sobre el operador \codigo{or}, por lo que no hacen falta paréntesis.
  \item \emph{Línea 3:} por otra parte, sí necesitas paréntesis alrededor de \codigo{x or y}\footnote{Este código es diferente de la línea anterior. Python interpreta primero el código \codigo{x or y}, el resultado es un \codigo{Boolean}, verdadero o falso, que se usa como clave para buscar si existe en el diccionario.}.
  \item \emph{Línea 4:} El operador \codigo{+} tiene precedencia sobre el operador \codigo{in}, por lo que esta línea, técnicamente, no necesita paréntesis alrededor de \codigo{x + y}, pero \codigo{2to3} los incluye para mayor legibilidad del código.
  \item \emph{Línea 5:} Esta forma sí que necesita paréntesis alrededor de \codigo{i in un\_diccionario} ya que el operador \codigo{+} tiene precedencia sobre \codigo{in}.
\end{enumerate}

\section{Métodos de diccionario que devuelven listas}

En Python 2, muchos métodos de diccionario devuelven listas. Los métodos más usados, como: \codigo{keys()}, \codigo{items()}, y \codigo{values()}. En Python 3, todos estos métodos devuelven vistas dinámicas. En algunos contextos, esto no es problema. Por ejemplo, si el valor de retorno de uno de estos métodos se pasa inmediatamente a otra función que itera a través de la secuencia completa, no hay diferencia visible si el tipo real es una lista o una vista. En otros contextos, sí tiene mucha importancia. Si estabas esperando una lista completa con elementos direccionables individualmente, el código fallará, ya que las vistas no soportan el indexado.

\begin{table}[htp]
  \centering
  \begin{tabular}{c l l}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1 & \codigo{mi\_diccionario.keys()} & \codigo{list(mi\_diccionario.keys())} \\
    2 & \codigo{mi\_diccionario.items()} & \codigo{list(mi\_diccionario.items())} \\
    3 & \codigo{mi\_diccionario.iterkeys()} & \codigo{iter(mi\_diccionario.keys())} \\
    4 & \codigo{[i for i in mi\_diccionario.iterkeys()]} & \codigo{[i for i in mi\_diccionario.keys()]} \\
    5 & \codigo{min(mi\_diccionario.keys())} & \emph{no cambia} \\
    \hline
  \end{tabular}
\end{table}
\FloatBarrier

\begin{enumerate}
  \item \emph{Línea 1:} \codigo{2to3} tiene a ir a lo más seguro, convirtiendo el valor de retorno de \codigo{keys()} a una lista estática con la función \codigo{list()}. Esto siempre funciona, pero será menos eficiente que utilizar una vista. Deberías examinar el código convertido para ver si es absolutamente necesaria la conversión, o si sería suficiente con una vista.
  \item \emph{Línea 2:} se produce otra conversión a lista con la función \codigo{items()}. Y también con la función \codigo{values()}.
  \item \emph{Línea 3:}Phyton 3 elimina el método \codigo{iterkeys()}. Utiliza \codigo{keys()} y, si es necesario, convierte la vista a un iterador con la función \codigo{iter()}.
  \item \emph{Línea 4:} \codigo{2to3} reconoce cuando el método \codigo{iterkeys()} se utiliza dentro de una comprensión de lista, y  lo convierte al método \codigo{keys()} (sin la llamada extra a la función \codigo{iter()}. Esto funciona porque las vistas son iterables.
  \item \emph{Línea 5:} \codigo{2to3} reconoce que el método \codigo{keys()} se va a pasar inmediatamente como parámetro de una función que itera a través de la secuencia completa, por eso no hay necesidad de convertir el valor de retorno en una lista. La función \codigo{min()} iterará sin problemas a través de la vista. Esto se aplica a los funciones: \codigo{min()}, \codigo{max()}, \codigo{sum()}, \codigo{list()}, \codigo{tuple()}, \codigo{set()}, \codigo{sorted()}, \codigo{any()} y \codigo{all()}.
\end{enumerate}

\section{Módulos que se han renombrado o reorganizado}

Se han renombrado varios módulos de la Librería Estándar de Python. Otros relacionados se han combinado o reorganizado para darles una asociación más lógica.

\subsection{\codigo{http}}

En Python 3, se han combinado en un único paquete, \codigo{http}, varios módulos relacionados con \codigo{HTTP}.

\begin{table}[htp]
  \centering
  \begin{tabular}{c l l}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1 & \codigo{import httplib} & \codigo{import http.client} \\
    2 & \codigo{import Cookie}  & \codigo{import http.cookies} \\
    3 & \codigo{import cookielib} & \codigo{import http.cookiejar} \\
    4 & \pbox{10cm}{\codigo{import BaseHTTPServer} \\
                    \codigo{import SimpleHTTPServer} \\
                    \codigo{import CGIHttpServer}} &
        \codigo{import http.server} \\
    \hline
  \end{tabular}
\end{table}

\begin{enumerate}
  \item \emph{Línea 1:} el módulo \codigo{http.client} implelmenta una librería de bajo nivel que puede solicitar recursos \codigo{HTTP} e interpretar respuestas \codigo{HTTP}.
  \item \emph{Línea 2:} el módulo \codigo{http.cookies} proporciona un interfaz \emph{pythonico} a las cookies del navegador que se envían en una cabecera \codigo{Set-Cookie: HTTP}.
  \item \emph{Línea 3:} el módulo \codigo{http.cookiejar} manipula los ficheros en los que se almacenan las cookies de los navegadores más populares.
  \item \emph{Línea 4:} el módulo \codigo{http.server} proporciona un servidor \codigo{HTTP} básico.
\end{enumerate}

\subsection{urllib}

Python 2 tiene un \emph{nido de ratas} de módulos solapados para procesar, codificar y recuperar \codigo{URL}s. En Python 3, se han refactorizado y combinado en un único paquete, \codigo{urllib}.


\begin{table}[htp]
  \centering
  \begin{tabular}{c l l}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1 & \codigo{import urllib} & \pbox{10cm}{
                                   \codigo{import urllib.request, urllib.parse,} \\
                                   \codigo{urllib.error}
                                 } \\
    2 & \codigo{import urllib2}  & \codigo{import urllib.request, urllib.error} \\
    3 & \codigo{import urlparse} & \codigo{import urllib.parse} \\
    4 & \codigo{import robotparse} & \codigo{import urllib.robotparse} \\
    5 & \pbox{10cm}{\codigo{from urllib import FancyURLopener} \\
                    \codigo{from urllib import urlencode}} &
        \pbox{10cm}{\codigo{from urllib.request import FancyURLopener} \\
                    \codigo{from urllib.parse urlencode}} \\
    6 & \pbox{10cm}{\codigo{from urllib2 import Request} \\
                    \codigo{from urllib2 import HTTPError}} &
        \pbox{10cm}{\codigo{from urllib.request import Request} \\
                    \codigo{from urllib.error HTTPError}} \\
    \hline
  \end{tabular}
\end{table}

\begin{enumerate}
  \item \emph{Línea 1:} el viejo módulo \codigo{urllib} de Python 2 tenía una gran variedad de funciones, incluida \codigo{urlopen()} para recuperar los datos, y \codigo{splittype()}, \codigo{splithost()}, y \codigo{splituser()} para dividir una \codigo{URL} en sus partes constituyentes. Estas funciones se han reorganizado de forma más lógica en el nuevo paquete \codigo{urllib}. \codigo{2to3} también modificará todas las llamadas a estas funciones para que utilicen este nuevo esquema de denominación
  \item \emph{Línea 2:} el viejo módulo \codigo{urllib2} de Python 2 se ha incorporado al paquete \codigo{urllib}. Todos los elementos conocidos de este paquete  ---El metodo \codigo{build\_opener()}, los objetos \codigo{Request}, \codigo{HTTPBasicAuthHandler} y otros--- están aún disponibles.
  \item \emph{Línea 3:} el módulo \codigo{urllib.parse} de Python 3 contiene todas las funciones del antiguo módulo \codigo{urlparse} de Python 2.
  \item \emph{Línea 4:} el módulo \codigo{urllib.robotparser} procesa ficheros \href{http://www.robotstxt.org/}{robots.txt}.
  \item \emph{Línea 5:} la clase \codigo{FancyURLopener}, que manera las redirecciones \codigo{HTTP} y otros códigos de estado, está aún disponible en el nuevo módulo \codigo{http.request}. La función \codigo{urlencode()} se ha movido a \codigo{urllib.parse}.
  \item \emph{Línea 6:} el objeto \codigo{Request} está aún disponible en \codigo{urllib.request}, pero las constantes como \codigo{HTTPError} se han movido a \codigo{urllib.error}.
\end{enumerate}

¿He mencionado que \codigo{2to3} reescribirá todas las llamadas a estas funciones? Por ejemplo, si tu código Python 2 importa el módulo \codigo{urllib} y llama a \codigo{urllib.urlopen()} para obtener datos, \codigo{2to3} arreglará arreglará ambas: la sentencia de importación y la llamada a la función.


\begin{table}[htp]
  \centering
  \begin{tabular}{c l l}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
     & \codigo{import urllib} & \pbox{10cm}{
                                   \codigo{import urllib.request, urllib.parse,} \\
                                   \codigo{urllib.error}
                                 } \\
                              &   \\
     & \pbox{10cm}{\codigo{print urllib.urlopen(} \\
     \codigo{    'http://diveintopython3.org').read()}}
     & \pbox{10cm}{\codigo{print urllib.request.urlopen(} \\
     \codigo{    'http://diveintopython3.org').read()}} \\
    \hline
  \end{tabular}
\end{table}

\subsection{\codigo{dbm}}

Los diversos clones de \codigo{DBM} se encuentran ahora en un único paquete, \codigo{dbm}. Si necesitas una variante específica, como \codigo{GNU DBM}, puedes importar el módulo apropiado de este paquete.

\begin{table}[htp]
  \centering
  \begin{tabular}{c l l}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    & \codigo{import dbm} & \codigo{import dbm.ndbm} \\
    & \codigo{import gdbm} & \codigo{import dbm.gnu} \\
    & \codigo{import dbhash} & \codigo{import dbm.bsd} \\
    & \codigo{import dumbdbm} & \codigo{import dbm.dumb} \\
    & \\
    & \pbox{10cm}{\codigo{import anydbm} \\ \codigo{import whichdb}}
      & \codigo{import dbm} \\
    \hline
  \end{tabular}
\end{table}
\FloatBarrier

\subsection{xmlrpc}

\codigo{XML-RPC} es un método ligero de hacer llamadas \codigo{RPC} sobre \codigo{HTTP}. La librería cliente \codigo{XML-RPC} y varias implementaciones de servidores \codigo{XML-RPC} se han combinado en un único paquete, \codigo{xmlrpc}.


\begin{table}[htp]
  \centering
  \begin{tabular}{c l l}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    & \codigo{import xmlrpclib} & \codigo{import xmlrpc.client} \\
    & \\
    & \pbox{10cm}{\codigo{import DocXMLRPCServer} \\ \codigo{import SimpleXMLRPCServer}}
      & \codigo{import xmlrpc.server} \\
    \hline
  \end{tabular}
\end{table}
\FloatBarrier

\subsection{Otros módulos}

\begin{table}
\centering
\begin{tabular}{c l l}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline

    1 &	\codigo{try:} & \codigo{import io} \\
    & \codigo{\quad import cStringIO as StringIO} \\
    & \codigo{except ImportError:} \\
    & \codigo{\quad import StringIO} \\
    & \\
    2 &	\codigo{try:} & \codigo{import pickle} \\
    & \codigo{\quad import cPickle as pickle} \\
    & \codigo{except ImportError:} \\
    & \codigo{\quad import pickle} \\

    & \\
    3 & \codigo{import \_\_builtin\_\_} & \codigo{import builtins} \\
    4 & \codigo{import copy\_reg} & \codigo{import copyreg} \\
    5 & \codigo{import Queue} & \codigo{import queue} \\
    6 & \codigo{import SocketServer} & \codigo{import socketserver} \\
    7 & \codigo{import ConfigParser} & \codigo{import configparser} \\
    8 & \codigo{import repr} & \codigo{import reprlib} \\
    9 & \codigo{import commands} & \codigo{import subprocess} \\
    \hline
\end{tabular}
\end{table}
\FloatBarrier

\begin{enumerate}
  \item \emph{Línea 1:} una construcción idiomática común en Python 2 era intentar importar \codigo{cStringIO} como \codigo{StringIO}, y si fallaba, importar la implementación \codigo{StringIO}. En Python 3 desaparece, el módulo \codigo{io} lo hace por ti. Encontrará la implementación más rápida disponible y la utilizará automáticamente.
  \item \emph{Línea 2:} una construcción similar se utilizaba para encontrar la implementación más rápida de \codigo{pickle}. En Python 3, el módulo \codigo{pickle} lo hace por ti.
  \item \emph{Línea 3:} el módulo \codigo{builtins} contiene las funciones globales, clases y constantes que se utilizan en todas partes. La redefinición de una función de este módulo la redefinirá en todas partes. Esto es tan potente y peligroso como parece.
  \item \emph{Línea 4:} el módulo \codigo{copyreg} añade soporte de pickle a los tipos de datos a medida definidos en C.
  \item \emph{Línea 5:} el módulo \codigo{queue} proporciona colas multiproductor-multiconsumidor.
  \item \emph{Línea 6:} el módulo \codigo{socketserver} proporciona una clase base genérica para implementar diferentes clases de servidores de sockets.
  \item \emph{Línea 7:} el módulo \codigo{configparser} procesa ficheros de configuración de estilo \codigo{INI}.
  \item \emph{Línea 8:} el módulo \codigo{reprlib} reimplementa la función interna \codigo{repr()}, añadiendo controles adicionales sobre lo larga que pueden ser las representaciones antes de ser truncadas.
  \item \emph{Línea 9:} el módulo \codigo{subprocess} te permite lanzar procesos, conectar sus flujos de entrada y de salida, y obtener sus códigos de retorno.
\end{enumerate}

\section{Importación relativa dentro de un paquete}

Un paquete es un grupo de módulos relacionados que funcionan como una única entidad. En Python 2, cuando los módulos de un paquete necesitaban referenciarse entre sí, podías utilizar \codigo{import foo} o \codigo{from foo import Bar}. El interprete de Python 2 primero buscaba en el paquete actual el fichero \codigo{foo.py}, y luego se movía a los demás directorios del camino de búsqueda (\codigo{sys.path}). Python 3 funciona diferente. En lugar de buscar en el paquete actua, va directamente al camino de búsqueda. Si quieres que un módulo de un pauqete importe a otro módulo en el mismo paquete, necesitas proporcionar explícitamente el camino relativo entre estos dos módulos.

Supón que tenías el siguiente paquete con múltiples ficheros en el mismo directorio:

% Figura de árbol con tikz

\tikzstyle{carpeta}=[draw=black,thick,anchor=west]
\tikzstyle{fichero}=[anchor=west]

\begin{tikzpicture}[%
  grow via three points={one child at (0.5,-0.7) and
  two children at (0.5,-0.7) and (0.5,-1.4)},
  edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}]
  \node [carpeta] {chardet/}
  child { node [fichero] {\_\_init\_\_.py}}
    child { node [fichero] {constants.py}}
    child { node [fichero] {mbcharsetprober.py}}
    child { node [fichero] {universaldetector.py}};
\end{tikzpicture}

Ahora supón que el fichero \codigo{universaldetector.py} necesita importar el contenido completo del fichero \codigo{constants.py} y una clase del fichero \codigo{mbcharsetprober.py}. ¿Cómo lo harías?

\begin{table}[htp]
  \centering
  \begin{tabular}{c l l}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1 & \codigo{import constants} & \codigo{from . import constants} \\
    & \\
    2 & \pbox{10cm}{\codigo{from mbcharsetprober import} \\
    \codigo{MultiByteCharSetProber}} &
    \pbox{10cm}{\codigo{from .mbcharsetprober import} \\
    \codigo{MultiByteCharsetProber}} \\
    \hline
  \end{tabular}
\end{table}

\begin{enumerate}
  \item \emph{Línea 1:} cuando necesitas importar un módulo completo de cualquier otra parte de tu paquete, utiliza la nueva sintaxis \codigo{from . import}. EL punto es el path relativo desde este fichero (\codigo{universaldetector.py}) al fichero que quieres importar (\codigo{constants.py}). En este caso, están en el mismo directorio, por lo que se coloca un único punto. También puedes importar desde el directorio padre (\codigo{from .. import otro\_módulo}) o desde un subdirectorio.
  \item \emph{Línea 2:} Para importar un clase específicao función desde otro módulo directamente en el espacio de nombres de tu módulo, introduce el prefijo del módulo objetivo con un camino relativo, sin usar la barra inclinada del final. En este caso, \codigo{mbcharsetprober.py} está en el mismo directorio que \codigo{universaldetector.py}, por lo que el camino es un único punto. También puedes importar desde el directorio padre (\codigo{from ..otro\_modulo import otra\_clase} o desde un subdirectorio.
\end{enumerate}

\section{El método iterador \codigo{next()}}

En Python 2, los iteradores tienen el método \codigo{next()} que devuelve el siguiente elemento de la secuencia. Esto sigue siendo cierto en Python 3, pero ahora hay también una función global \href{http://www.diveintopython3.net/generators.html#generators}{\codigo{next()}} que toma un iterador como parámetro.

\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1 & \codigo{unIterador.next()} & \codigo{next(unIterador)} \\
    2 & \codigo{función\_q\_retorna\_iterador().next()} &
        \codigo{next(función\_q\_retorna\_iterador())} \\
    & \\
    3 & \codigo{class A:} & \codigo{class A:} \\
      & \quad \codigo{def next(self):} & \quad \codigo{def \_\_next\_\_(self):}\\
      & \quad\quad \codigo{pass} & \quad\quad \codigo{pass} \\

    & \\
    4 & \codigo{class A:} & \\
    & \quad\codigo{def next(self, x, y):} & \emph{no cambia} \\
    &  \quad\quad\codigo{pass} \\
    \hline
  \end{tabular}
\end{table}


