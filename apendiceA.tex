
% apendiceA.tex
% This work is licensed under the Creative Commons Attribution-Noncommercial-Share Alike 3.0 License.
% To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/nz
% or send a letter to Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.

\chapter{Migrando código a Python 3 con \codigo{2to3}} \label{ch:migcod}

\noindent Nivel de dificultad:\diflllll

\begin{citaCap}
    ``La vida es agradable. La muerte es tranquilidad. Es la transición lo que es problemático.'' \\
        ---\emph{atribuido a Isaac Asimov}
\end{citaCap}

\section{Inmersión}

 Han cambiado tantas cosas entre Python 2 y Python 3 que son pocos los programas que funcionan con ambos sin modificaciones. ¡Pero no te desalientes! Para ayudar con la transición, Python 3 incorpora una herramienta denomidada \codigo{2to3}, que analiza el código fuente en Python 2 y lo convierte en Python 3 tanto como puede. El capítulo \ref{ch:chardet}, se describe como ejecutar \codigo{2to3}, y muestra algunas cosas que este no puede resolver de forma automática. Este apéndice documenta aquello que sí puede convertir de forma automática.

\section{La sentencia \codigo{print}}

En Python 2, \codigo{print} era una sentencia. Lo que quisieras imprimir iba detrás de ella. En Python 3, \codigo{print()} es una función. Lo quieras imprimir debe pasarse como parámetro, igual que en cualquier otra función.

\begin{table}
  \centering
  \begin{tabular}{ c l l }
  \hline
  Línea & Python 2 & Python 3 \\
  \hline
  1 & \codigo{print}                & \codigo{print()} \\
  2 & \codigo{print 1}              & \codigo{print(1)} \\
  3 & \codigo{print 1, 2}           & \codigo{print(1, 2)} \\
  4 & \codigo{print >{}>sys.stderr, 1, 2, 3} & \codigo{print(1, 2, 3, file=sys.stderr)} \\
  \hline
  \end{tabular}
\end{table}
\FloatBarrier

\begin{enumerate}
  \item \emph{Línea 1:} imprime una línea vacía.
  \item \emph{Línea 2:} imprime un único valor.
  \item \emph{Línea 3:} imprime dos valores separados por espacios.
  \item \emph{Línea 4:} este es un poco complejo. En Python 2, si finalizabas la sentencia \codigo{print} con una coma se imprimían los valores separados por espacios, luego añadía un espacio al final, y paraba sin imprimir un retorno de carro\footnote{Técnicamente, es un poco más complicado. La sentencia \codigo{print} en Python 2 utilizaba un atributo que está ``deprecado'' denominado \codigo{softspace}. En lugar de imprimir un espacio, Python 2 activaba \codigo{sys.stdout.softspace} a 1. El carácter de espacio, no se imprimía hasta que tu aplicación no imprimiera algo más en la misma línea. Si la siguiente sentencia \codigo{print} imprimía un retorno de carro, \codigo{sys.stdout.softspace} pasaría a valer 0 y el espacio nunca se imprimiría. Probablemente nunca te dieras cuenta de la diferencia a menos que tu aplicación fuese sensible a la presencia o ausencia de espacios en blanco al final de las líneas en la salida generada por \codigo{print}.}. En Python 3, la forma de hacer esto es pasar \codigo{end=' '} como un parámetro de la función \codigo{print()}. El parámetro \codigo{end} tiene como valor por defecto \codigo{'\textbackslash n'} (el retorno de carro), por lo que su sustitución elimina el retorno de carro después de imprimir los demás parámetros.

  \item \emph{Línea 5:} en Python 2, puedes redirigir la salida a un flujo diferente de la salida estándar ---como \codigo{sys.stderr}--- mediante el uso de la sintaxis \codigo{>{}>nombre\_de\_flujo}. En Python 3, la forma de hacer esto es pasar el flujo como parámetro \codigo{file}. El valor por defecto de este parámetro es \codigo{sys.stdout} (la salida estándar), por lo que sustituirlo enviará la salida a otro flujo diferente.

\end{enumerate}


\section{Cadenas de caracteres Unicode}

Python 2 tiene dos tipos de cadenas de caracteres: Unicode y no Unicode. Python 3 solo tiene un tipo: Unicode.


\begin{table}
  \centering
  \begin{tabular}{ c l l }
  \hline
  Línea & Python 2 & Python 3 \\
  \hline
  1 & \codigo{u'PapayaWhip'}              & \codigo{'PapayaWhip'} \\
  2 & \codigo{ur'PapayaWhip\textbackslash foo'}             & \codigo{r'PapayaWhip\textbackslash foo'} \\
  \hline
  \end{tabular}
\end{table}
\FloatBarrier

\begin{enumerate}
  \item \emph{Línea 1:} las cadenas de caracteres Unicode se escriben directamente como cadenas de caracteres, que en Python 3 siempre son Unicode.
  \item \emph{Línea 2:} las cadenas de caracteres Unicode Raw (que en Python permiten evitar los caracteres de escape de la barra inclinada invertida) se convierten en cadenas de caracteres Raw, que en Python 3, siempre son Unicode.
\end{enumerate}

\section{La función global \codigo{unicode()}}

Python 2 dispone de dos funciones globales para convertir objetos a cadenas de caracteres: \codigo{unicode()} para convertirlas en cadenas Unicode, y \codigo{str()} para convertirlas en cadenas no Unicode. Python 3 solamente tiene un tipo de cadenas de caracteres, Unicode, por lo que solamente existe la función \codigo{str()}. La función \codigo{unicode()} no existe.

\begin{table}[htp]
  \centering
  \begin{tabular}{c l l}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    & \codigo{unicode(cualquier\_objeto)} & \codigo{str(cualquier\_objeto)} \\
    \hline
  \end{tabular}
\end{table}
\FloatBarrier

\section{El tipo de datos \codigo{long}}

Python 2 tiene dos tipos de datos para números enteros: \codigo{int} y \codigo{long}. Un \codigo{int} no puede ser mayor que \codigo{sys.maxint}, que es diferente según la plataforma. El tipo \codigo{long} se define añadiendo una 'L' al final del número, y puede ser, bueno, más grande que un \codigo{int}.

En Python 3, solamente existe un tipo de números enteros, denominado \codigo{int}, que se comporta como el tipo \codigo{long} de Python 2. Puesto que no existen dos tipos, no hay necesidad de una sintaxis especial para distinguirlos.

Para profundizar, se puede leer el documento \href{http://www.python.org/dev/peps/pep-0237/}{PEP 237: unificando los enteros long e int.}

\begin{table}
  \centering
  \begin{tabular}{c l l }
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1 & \codigo{x = 1000000000000L} & \codigo{x = 1000000000000} \\
    2 & \codigo{x = 0xFFFFFFFFFFFFL} & \codigo{x = 0xFFFFFFFFFFFF} \\
    3 & \codigo{long(x)} & \codigo{int(x)} \\
    4 & \codigo{type(x) is long} & \codigo{type(x) is int} \\
    5 & \codigo{isinstance(x, long)} & \codigo{isinstance(x, int)} \\
    \hline
  \end{tabular}
\end{table}
\FloatBarrier

\begin{enumerate}
  \item \emph{Línea 1:} los enteros largos en base 10 se transforman en enteros en base 10.
  \item \emph{Línea 2:} los enteros largos en base 16 se transforman en enteros en base 16.
  \item \emph{Línea 3:} en Python 3, la función \codigo{long()} desaparece. Para forzar una variable al tipo entero, se utiliza la función \codigo{int()}.
  \item \emph{Línea 4:} la función \codigo{isinstance()} sirve para comprobar el tipo de datos de una variable; de nueveo, se debe utilizar \codigo{int} en lugar de \codigo{long}.
\end{enumerate}

\section{Comparación <{}>}

Python 2 soporta \codigo{<{}>} como sinónimo de \codigo{!=}, el operador de comparación de desigualdad. Python 3 tiene este operador, pero \codigo{<{}>} deja de existir.

\begin{table}[htp]
  \centering
  \begin{tabular}{c l l}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1 & \codigo{if x <{}> y:} & \codigo{if x != y:} \\
    2 & \codigo{if x <{}> y <{}> z:} & \codigo{if x != y != z:} \\
    \hline
  \end{tabular}
\end{table}

\begin{enumerate}
  \item  \emph{Línea 1:} una comparación simple.
  \item  \emph{Línea 2:} una comparación más compleja entre tres valores.
\end{enumerate}

\section{\codigo{Método de diccionarios: has\_key()}}

En Python 2, los diccionarios tienen un método \codigo{has\_key()} para comprobar si el diccionario contiene una determinada clave. En Python 3, este método no existe. En su lugar, debes utilizar el operador \codigo{in}.

\begin{table}[htp]
  \centering
  \begin{tabular}{c l l}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1 & \codigo{un\_diccionario.has\_key('PapayaWhip')}
      & \codigo{'PapayaWhip' in un\_diccionario} \\
      \\
    2 & \pbox{10cm}{\codigo{un\_diccionario.has\_key(x) or} \\ 
                    \codigo{un\_diccionario.has\_key(y)}}
      & \pbox{10cm}{\codigo{x in un\_diccionario or} \\
                    \codigo{y in un\_diccionario}} \\
      \\
    3 & \codigo{un\_diccionario.has\_key(x or y)}
      & \codigo{(x or y) in un\_diccionario} \\
    4 & \codigo{un\_diccionario.has\_key(x + y)}
      & \codigo{(x + y) in un\_diccionario} \\
    5 & \codigo{x + un\_diccionario.has\_key(y)}
      & \codigo{x + (y in un\_diccionario)} \\
    \hline
  \end{tabular}
\end{table}
\FloatBarrier

\begin{enumerate}
  \item \emph{Línea 1:} la forma más simple.
  \item \emph{Línea 2:} el operador \codigo{in} tiene precedencia sobre el operador \codigo{or}, por lo que no hacen falta paréntesis.
  \item \emph{Línea 3:} por otra parte, sí necesitas paréntesis alrededor de \codigo{x or y}\footnote{Este código es diferente de la línea anterior. Python interpreta primero el código \codigo{x or y}, el resultado es un \codigo{Boolean}, verdadero o falso, que se usa como clave para buscar si existe en el diccionario.}.
  \item \emph{Línea 4:} El operador \codigo{+} tiene precedencia sobre el operador \codigo{in}, por lo que esta línea, técnicamente, no necesita paréntesis alrededor de \codigo{x + y}, pero \codigo{2to3} los incluye para mayor legibilidad del código.
  \item \emph{Línea 5:} Esta forma sí que necesita paréntesis alrededor de \codigo{i in un\_diccionario} ya que el operador \codigo{+} tiene precedencia sobre \codigo{in}.
\end{enumerate}

\section{Métodos de diccionario que devuelven listas}

En Python 2, muchos métodos de diccionario devuelven listas. Los métodos más usados, como: \codigo{keys()}, \codigo{items()}, y \codigo{values()}. En Python 3, todos estos métodos devuelven vistas dinámicas. En algunos contextos, esto no es problema. Por ejemplo, si el valor de retorno de uno de estos métodos se pasa inmediatamente a otra función que itera a través de la secuencia completa, no hay diferencia visible si el tipo real es una lista o una vista. En otros contextos, sí tiene mucha importancia. Si estabas esperando una lista completa con elementos direccionables individualmente, el código fallará, ya que las vistas no soportan el indexado.

\begin{table}[htp]
  \centering
  \begin{tabular}{c l l}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1 & \codigo{mi\_diccionario.keys()} & \codigo{list(mi\_diccionario.keys())} \\
    2 & \codigo{mi\_diccionario.items()} & \codigo{list(mi\_diccionario.items())} \\
    3 & \codigo{mi\_diccionario.iterkeys()} & \codigo{iter(mi\_diccionario.keys())} \\
    4 & \codigo{[i for i in mi\_diccionario.iterkeys()]} & \codigo{[i for i in mi\_diccionario.keys()]} \\
    5 & \codigo{min(mi\_diccionario.keys())} & \emph{no cambia} \\
    \hline
  \end{tabular}
\end{table}
\FloatBarrier

\begin{enumerate}
  \item \emph{Línea 1:} \codigo{2to3} tiene a ir a lo más seguro, convirtiendo el valor de retorno de \codigo{keys()} a una lista estática con la función \codigo{list()}. Esto siempre funciona, pero será menos eficiente que utilizar una vista. Deberías examinar el código convertido para ver si es absolutamente necesaria la conversión, o si sería suficiente con una vista.
  \item \emph{Línea 2:} se produce otra conversión a lista con la función \codigo{items()}. Y también con la función \codigo{values()}.
  \item \emph{Línea 3:}Phyton 3 elimina el método \codigo{iterkeys()}. Utiliza \codigo{keys()} y, si es necesario, convierte la vista a un iterador con la función \codigo{iter()}.
  \item \emph{Línea 4:} \codigo{2to3} reconoce cuando el método \codigo{iterkeys()} se utiliza dentro de una comprensión de lista, y  lo convierte al método \codigo{keys()} (sin la llamada extra a la función \codigo{iter()}. Esto funciona porque las vistas son iterables.
  \item \emph{Línea 5:} \codigo{2to3} reconoce que el método \codigo{keys()} se va a pasar inmediatamente como parámetro de una función que itera a través de la secuencia completa, por eso no hay necesidad de convertir el valor de retorno en una lista. La función \codigo{min()} iterará sin problemas a través de la vista. Esto se aplica a los funciones: \codigo{min()}, \codigo{max()}, \codigo{sum()}, \codigo{list()}, \codigo{tuple()}, \codigo{set()}, \codigo{sorted()}, \codigo{any()} y \codigo{all()}.
\end{enumerate}

\section{Módulos que se han renombrado o reorganizado}

Se han renombrado varios módulos de la Librería Estándar de Python. Otros relacionados se han combinado o reorganizado para darles una asociación más lógica.

\subsection{\codigo{http}}

En Python 3, se han combinado en un único paquete, \codigo{http}, varios módulos relacionados con \codigo{HTTP}.

\begin{table}[htp]
  \centering
  \begin{tabular}{c l l}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1 & \codigo{import httplib} & \codigo{import http.client} \\
    2 & \codigo{import Cookie}  & \codigo{import http.cookies} \\
    3 & \codigo{import cookielib} & \codigo{import http.cookiejar} \\
    4 & \pbox{10cm}{\codigo{import BaseHTTPServer} \\
                    \codigo{import SimpleHTTPServer} \\
                    \codigo{import CGIHttpServer}} &
        \codigo{import http.server} \\
    \hline
  \end{tabular}
\end{table}

\begin{enumerate}
  \item \emph{Línea 1:} el módulo \codigo{http.client} implelmenta una librería de bajo nivel que puede solicitar recursos \codigo{HTTP} e interpretar respuestas \codigo{HTTP}.
  \item \emph{Línea 2:} el módulo \codigo{http.cookies} proporciona un interfaz \emph{pythonico} a las cookies del navegador que se envían en una cabecera \codigo{Set-Cookie: HTTP}.
  \item \emph{Línea 3:} el módulo \codigo{http.cookiejar} manipula los ficheros en los que se almacenan las cookies de los navegadores más populares.
  \item \emph{Línea 4:} el módulo \codigo{http.server} proporciona un servidor \codigo{HTTP} básico.
\end{enumerate}

\subsection{urllib}

Python 2 tiene un \emph{nido de ratas} de módulos solapados para procesar, codificar y recuperar \codigo{URL}s. En Python 3, se han refactorizado y combinado en un único paquete, \codigo{urllib}.


\begin{table}[htp]
  \centering
  \begin{tabular}{c l l}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1 & \codigo{import urllib} & \pbox{10cm}{
                                   \codigo{import urllib.request, urllib.parse,} \\
                                   \codigo{urllib.error}
                                 } \\
    2 & \codigo{import urllib2}  & \codigo{import urllib.request, urllib.error} \\
    3 & \codigo{import urlparse} & \codigo{import urllib.parse} \\
    4 & \codigo{import robotparse} & \codigo{import urllib.robotparse} \\
    5 & \pbox{10cm}{\codigo{from urllib import FancyURLopener} \\
                    \codigo{from urllib import urlencode}} &
        \pbox{10cm}{\codigo{from urllib.request import FancyURLopener} \\
                    \codigo{from urllib.parse urlencode}} \\
    6 & \pbox{10cm}{\codigo{from urllib2 import Request} \\
                    \codigo{from urllib2 import HTTPError}} &
        \pbox{10cm}{\codigo{from urllib.request import Request} \\
                    \codigo{from urllib.error HTTPError}} \\
    \hline
  \end{tabular}
\end{table}

\begin{enumerate}
  \item \emph{Línea 1:} el viejo módulo \codigo{urllib} de Python 2 tenía una gran variedad de funciones, incluida \codigo{urlopen()} para recuperar los datos, y \codigo{splittype()}, \codigo{splithost()}, y \codigo{splituser()} para dividir una \codigo{URL} en sus partes constituyentes. Estas funciones se han reorganizado de forma más lógica en el nuevo paquete \codigo{urllib}. \codigo{2to3} también modificará todas las llamadas a estas funciones para que utilicen este nuevo esquema de denominación
  \item \emph{Línea 2:} el viejo módulo \codigo{urllib2} de Python 2 se ha incorporado al paquete \codigo{urllib}. Todos los elementos conocidos de este paquete  ---El metodo \codigo{build\_opener()}, los objetos \codigo{Request}, \codigo{HTTPBasicAuthHandler} y otros--- están aún disponibles.
  \item \emph{Línea 3:} el módulo \codigo{urllib.parse} de Python 3 contiene todas las funciones del antiguo módulo \codigo{urlparse} de Python 2.
  \item \emph{Línea 4:} el módulo \codigo{urllib.robotparser} procesa ficheros \href{http://www.robotstxt.org/}{robots.txt}.
  \item \emph{Línea 5:} la clase \codigo{FancyURLopener}, que manera las redirecciones \codigo{HTTP} y otros códigos de estado, está aún disponible en el nuevo módulo \codigo{http.request}. La función \codigo{urlencode()} se ha movido a \codigo{urllib.parse}.
  \item \emph{Línea 6:} el objeto \codigo{Request} está aún disponible en \codigo{urllib.request}, pero las constantes como \codigo{HTTPError} se han movido a \codigo{urllib.error}.
\end{enumerate}

¿He mencionado que \codigo{2to3} reescribirá todas las llamadas a estas funciones? Por ejemplo, si tu código Python 2 importa el módulo \codigo{urllib} y llama a \codigo{urllib.urlopen()} para obtener datos, \codigo{2to3} arreglará arreglará ambas: la sentencia de importación y la llamada a la función.


\begin{table}[htp]
  \centering
  \begin{tabular}{c l l}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
     & \codigo{import urllib} & \pbox{10cm}{
                                   \codigo{import urllib.request, urllib.parse,} \\
                                   \codigo{urllib.error}
                                 } \\
                              &   \\
     & \pbox{10cm}{\codigo{print urllib.urlopen(} \\
     \codigo{    'http://diveintopython3.org').read()}}
     & \pbox{10cm}{\codigo{print urllib.request.urlopen(} \\
     \codigo{    'http://diveintopython3.org').read()}} \\
    \hline
  \end{tabular}
\end{table}

\subsection{\codigo{dbm}}

Los diversos clones de \codigo{DBM} se encuentran ahora en un único paquete, \codigo{dbm}. Si necesitas una variante específica, como \codigo{GNU DBM}, puedes importar el módulo apropiado de este paquete.

\begin{table}[htp]
  \centering
  \begin{tabular}{c l l}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    & \codigo{import dbm} & \codigo{import dbm.ndbm} \\
    & \codigo{import gdbm} & \codigo{import dbm.gnu} \\
    & \codigo{import dbhash} & \codigo{import dbm.bsd} \\
    & \codigo{import dumbdbm} & \codigo{import dbm.dumb} \\
    & \\
    & \pbox{10cm}{\codigo{import anydbm} \\ \codigo{import whichdb}}
      & \codigo{import dbm} \\
    \hline
  \end{tabular}
\end{table}
\FloatBarrier

\subsection{xmlrpc}

\codigo{XML-RPC} es un método ligero de hacer llamadas \codigo{RPC} sobre \codigo{HTTP}. La librería cliente \codigo{XML-RPC} y varias implementaciones de servidores \codigo{XML-RPC} se han combinado en un único paquete, \codigo{xmlrpc}.


\begin{table}[htp]
  \centering
  \begin{tabular}{c l l}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    & \codigo{import xmlrpclib} & \codigo{import xmlrpc.client} \\
    & \\
    & \pbox{10cm}{\codigo{import DocXMLRPCServer} \\ \codigo{import SimpleXMLRPCServer}}
      & \codigo{import xmlrpc.server} \\
    \hline
  \end{tabular}
\end{table}
\FloatBarrier

\subsection{Otros módulos}

\begin{table}
\centering
\begin{tabular}{c l l}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline

    1 &	\codigo{try:} & \codigo{import io} \\
    & \codigo{\quad import cStringIO as StringIO} \\
    & \codigo{except ImportError:} \\
    & \codigo{\quad import StringIO} \\
    & \\
    2 &	\codigo{try:} & \codigo{import pickle} \\
    & \codigo{\quad import cPickle as pickle} \\
    & \codigo{except ImportError:} \\
    & \codigo{\quad import pickle} \\

    & \\
    3 & \codigo{import \_\_builtin\_\_} & \codigo{import builtins} \\
    4 & \codigo{import copy\_reg} & \codigo{import copyreg} \\
    5 & \codigo{import Queue} & \codigo{import queue} \\
    6 & \codigo{import SocketServer} & \codigo{import socketserver} \\
    7 & \codigo{import ConfigParser} & \codigo{import configparser} \\
    8 & \codigo{import repr} & \codigo{import reprlib} \\
    9 & \codigo{import commands} & \codigo{import subprocess} \\
    \hline
\end{tabular}
\end{table}
\FloatBarrier

\begin{enumerate}
  \item \emph{Línea 1:} una construcción idiomática común en Python 2 era intentar importar \codigo{cStringIO} como \codigo{StringIO}, y si fallaba, importar la implementación \codigo{StringIO}. En Python 3 desaparece, el módulo \codigo{io} lo hace por ti. Encontrará la implementación más rápida disponible y la utilizará automáticamente.
  \item \emph{Línea 2:} una construcción similar se utilizaba para encontrar la implementación más rápida de \codigo{pickle}. En Python 3, el módulo \codigo{pickle} lo hace por ti.
  \item \emph{Línea 3:} el módulo \codigo{builtins} contiene las funciones globales, clases y constantes que se utilizan en todas partes. La redefinición de una función de este módulo la redefinirá en todas partes. Esto es tan potente y peligroso como parece.
  \item \emph{Línea 4:} el módulo \codigo{copyreg} añade soporte de pickle a los tipos de datos a medida definidos en C.
  \item \emph{Línea 5:} el módulo \codigo{queue} proporciona colas multiproductor-multiconsumidor.
  \item \emph{Línea 6:} el módulo \codigo{socketserver} proporciona una clase base genérica para implementar diferentes clases de servidores de sockets.
  \item \emph{Línea 7:} el módulo \codigo{configparser} procesa ficheros de configuración de estilo \codigo{INI}.
  \item \emph{Línea 8:} el módulo \codigo{reprlib} reimplementa la función interna \codigo{repr()}, añadiendo controles adicionales sobre lo larga que pueden ser las representaciones antes de ser truncadas.
  \item \emph{Línea 9:} el módulo \codigo{subprocess} te permite lanzar procesos, conectar sus flujos de entrada y de salida, y obtener sus códigos de retorno.
\end{enumerate}

\section{Importación relativa dentro de un paquete}

Un paquete es un grupo de módulos relacionados que funcionan como una única entidad. En Python 2, cuando los módulos de un paquete necesitaban referenciarse entre sí, podías utilizar \codigo{import foo} o \codigo{from foo import Bar}. El interprete de Python 2 primero buscaba en el paquete actual el fichero \codigo{foo.py}, y luego se movía a los demás directorios del camino de búsqueda (\codigo{sys.path}). Python 3 funciona diferente. En lugar de buscar en el paquete actua, va directamente al camino de búsqueda. Si quieres que un módulo de un pauqete importe a otro módulo en el mismo paquete, necesitas proporcionar explícitamente el camino relativo entre estos dos módulos.

Supón que tenías el siguiente paquete con múltiples ficheros en el mismo directorio:

% Figura de árbol con tikz

\tikzstyle{carpeta}=[draw=black,thick,anchor=west]
\tikzstyle{fichero}=[anchor=west]

\begin{tikzpicture}[%
  grow via three points={one child at (0.5,-0.7) and
  two children at (0.5,-0.7) and (0.5,-1.4)},
  edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}]
  \node [carpeta] {chardet/}
  child { node [fichero] {\_\_init\_\_.py}}
    child { node [fichero] {constants.py}}
    child { node [fichero] {mbcharsetprober.py}}
    child { node [fichero] {universaldetector.py}};
\end{tikzpicture}

Ahora supón que el fichero \codigo{universaldetector.py} necesita importar el contenido completo del fichero \codigo{constants.py} y una clase del fichero \codigo{mbcharsetprober.py}. ¿Cómo lo harías?

\begin{table}[htp]
  \centering
  \begin{tabular}{c l l}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1 & \codigo{import constants} & \codigo{from . import constants} \\
    & \\
    2 & \pbox{10cm}{\codigo{from mbcharsetprober import} \\
    \codigo{MultiByteCharSetProber}} &
    \pbox{10cm}{\codigo{from .mbcharsetprober import} \\
    \codigo{MultiByteCharsetProber}} \\
    \hline
  \end{tabular}
\end{table}

\begin{enumerate}
  \item \emph{Línea 1:} cuando necesitas importar un módulo completo de cualquier otra parte de tu paquete, utiliza la nueva sintaxis \codigo{from . import}. EL punto es el path relativo desde este fichero (\codigo{universaldetector.py}) al fichero que quieres importar (\codigo{constants.py}). En este caso, están en el mismo directorio, por lo que se coloca un único punto. También puedes importar desde el directorio padre (\codigo{from .. import otro\_módulo}) o desde un subdirectorio.
  \item \emph{Línea 2:} Para importar un clase específicao función desde otro módulo directamente en el espacio de nombres de tu módulo, introduce el prefijo del módulo objetivo con un camino relativo, sin usar la barra inclinada del final. En este caso, \codigo{mbcharsetprober.py} está en el mismo directorio que \codigo{universaldetector.py}, por lo que el camino es un único punto. También puedes importar desde el directorio padre (\codigo{from ..otro\_modulo import otra\_clase} o desde un subdirectorio.
\end{enumerate}

\section{El método iterador \codigo{next()}}

En Python 2, los iteradores tienen el método \codigo{next()} que devuelve el siguiente elemento de la secuencia. Esto sigue siendo cierto en Python 3, pero ahora hay también una función global \href{http://www.diveintopython3.net/generators.html#generators}{\codigo{next()}} que toma un iterador como parámetro.

\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1 & \codigo{unIterador.next()} & \codigo{next(unIterador)} \\
    2 & \codigo{función\_q\_retorna\_iterador().next()} &
        \codigo{next(función\_q\_retorna\_iterador())} \\
    & \\
    3 & \codigo{class A:} & \codigo{class A:} \\
      & \quad \codigo{def next(self):} & \quad \codigo{def \_\_next\_\_(self):}\\
      & \quad\quad \codigo{pass} & \quad\quad \codigo{pass} \\

    & \\
    4 & \codigo{class A:} & \\
    & \quad\codigo{def next(self, x, y):} & \emph{no cambia} \\
    &  \quad\quad\codigo{pass} \\
    \hline
  \end{tabular}
\end{table}

\begin{enumerate}
  \item \emph{Línea 1:} en el caso más simple, en lugar de llamar al método \codigo{next()} del iterador, ahora puedes pasar el propio iterador a la función global \codigo{next()}.
  \item \emph{Línea 2:} si tienes una función que devuelve un iterador, puedes llamar a la función y pasarle el resultado a la función \codigo{next()}.
  \item \emph{Línea 3:} si defines tu propia clase y quieres usarla como un iterador, debes definir el método especial \codigo{\_\_next\_\_()}.
  \item \emph{Línea 4:} si defines tu clase y resulta que ya tiene un método \codigo{next()} con uno o más parámetros (sin contar \codigo{self}), \codigo{2to3} no la modificará. Esta clase no podrá utilizarse como iterador puesto que su método \codigo{next()} tiene parámetros.
  \item \emph{Línea 5:} esta última es un poco compleja. Si tienes una variable local que se llame \codigo{next}, tiene precedencia sobre la nueva función global \codigo{next()}. En este caso, necestias llamar al método especial \codigo{\_\_next\_\_()} directamente para poder obtener el siguiente elemento de la secuencia (Alternativamente, podrías refactorizar el código para que la variable local no se llamara \codigo{next}, pero \codigo{2to3} no lo hará por ti.
\end{enumerate}

\section{La función global \codigo{filter()}}

En Python 2, la función \codigo{filter()} devolvía una lista, el resultado de filtrar una secuencia a través de una función que devolviera \codigo{True} o \codigo{False} para cada elemento de la secuencia. En Python 3, la función \codigo{filter()} devuelve un iterador, no una lista.

\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1 & \codigo{filter(función, secuencia)} & \codigo{list(filter(función, secuencia))} \\
    2 & \codigo{list(filter(función, secuencia))} & \codigo{\emph{no cambia}} \\
    3 & \codigo{filter(None, secuencia)} & \codigo{[i for i in secuencia if i]} \\
    4 & \codigo{for i in filter(None, secuencia):} & \codigo{\emph{no cambia}} \\
    5 & \codigo{[i for i in filter(función, secuencia)]} & \codigo{\emph{no cambia}} \\
    \hline
  \end{tabular}
\end{table}

\begin{enumerate}
  \item \emph{Línea 1:} en el caso básico, \codigo{2to3} envolverá la llamada a \codigo{filter()} con una llamada a \codigo{list()}, lo que simplemente itera y devuelve una lista verdadera.
  \item \emph{Línea 2:} sin embargo, si la llamada a \codigo{filter()} ya está envuelta en una llamada a \codigo{list()}, \codigo{2to3} no hará nada, ya que no es necesario.
  \item \emph{Línea 3:} para sintaxis especial \codigo{filter(None, \ldots)}, \codigo{2to3} transformará la llamada en una comprensión de lista semánticamente equivalente.
  \item \emph{Línea 4:} en contextos como el bucle \codigo{for}, que iteran a través de la secuencia completa siempre, no se requieren cambios.
  \item \emph{Línea 5:} tampoco se requieren cambios, cuando ya se itere de forma completa por encontrarse \codigo{filter()} en una sentencia de comprensión de listas.
\end{enumerate}

\section{La función global \codigo{map()}}

De forma parecida a como se comporta \codigo{filter()}, la función \codigo{map()} ahora devuelve un iterador (En Python 2, devolvía una lista).

\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1 & \codigo{map(función, 'PapayaWhip')} & \codigo{list(map(función, 'PapayaWhip'))} \\
    2 & \codigo{map(None, 'PapayaWhip')} & \codigo{list('PapayaWhip')} \\
    2 & \codigo{map(lambda x: x+1, range(42))} & \codigo{[x+1 for x in range(42)]} \\
    4 & \codigo{for i in map(None, secuencia):} & \codigo{\emph{no cambia}} \\
    5 & \codigo{[i for i in map(función, secuencia)]} & \codigo{\emph{no cambia}} \\
    \hline
  \end{tabular}
\end{table}
\FloatBarrier

\begin{enumerate}
  \item \emph{Línea 1:} como sucede con \codigo{filter()}, en el caso más básico, \codigo{2to3} envolverá la llamada a \codigo{map()}con una llamada a \codigo{list()}.
  \item \emph{Línea 2:} para la sintaxis especial \codigo{map(None, \ldots)}, la función identidad, \codigo{2to3} la convertirá en una llamada equivalente a \codigo{list()}.
  \item \emph{Línea 3:} si el primer argumento de \codigo{map()} es una función lambda, \codigo{2to3} la convertirá en una comprensión de listas equivalente.
  \item \emph{Línea 4:} en contextos como los bucles \codigo{for}, en los que se itera a través de la secuencia completa, no se requieren cambios.
  \item \emph{Línea 4:} de nuevo, no hacen falta cambios, ya que la comprensión de listas iterará a través de la secuencia completa, y esto es posible tanto si el valor de retorno de \codigo{map()} es un iterador, como si es una lista.
\end{enumerate}

\section{La función global \codigo{reduce()}}

En Python 3, se ha suprimido la función \codigo{reduce()} del espacio de nombres global, y se ha colocado en el módulo \codigo{functools}.


\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    & \codigo{reduce(a, b, c)} & from functools import reduce \\
    & & \codigo{reduce(a, b, c)} \\
    \hline
  \end{tabular}
\end{table}


\section{La función global \codigo{apply()}}

Python 2 tiene una función global denominada \codigo{apply()}, que toma una función \codigo{f} y una lista \codigo{[a, b, c]} y devuelve \codigo{f(a, b, c)}. Puedes conseguir el mismo resultado mediante la llamada directa a la función pasándole la lista de parámetros precedida de un asterisco. En Python 3, la función \codigo{apply()} ha dejado de existir; debes usar obligatoriamente la notación asterisco.


\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1  & \codigo{apply(funcion, listaParametros)} & \codigo{funcion(*listaParametros)} \\
    2  & \codigo{apply(funcion, listaParametros,} & \codigo{funcion(*listaParametros,} \\
    & \quad \codigo{dicParamNombre)} & \quad \codigo{**dicParamNombre)} \\
    3  & \codigo{apply(funcion, listaParametros + z)} & \codigo{funcion(listaParametros + z)} \\
    4  & \codigo{apply(modulo.funcion, listaParam)} & \codigo{modulo.funcion(listaParam)} \\
    \hline
  \end{tabular}
\end{table}

\begin{enumerate}
  \item \emph{Línea 1:} en su forma más simple, puedes llamar a una función con una lista de parámetros añadiendo un asterisco delante de la lista. Esto es equivalente a la anterior función \codigo{apply()} de Python 2.
  \item \emph{Línea 2:} en Python 2, la función \codigo{apply()} podría tomar hasta tres parámetros: una función, la lista de parámetros, y un diccionario con los parámetros que se pasan por nombre. En Python 3, puedes conseguir el mismo efecto añadiendo un asterisco a la lista de parámetros y dos asteriscos al diccionario con los parámetros que se pasan por nombre.
  \item \emph{Línea 3:} El operador \codigo{+}, utilizado aquí para la concatenación de listas, tiene prioridad sobre el operador \codigo{*} (asterisco), por eso no hay necesidad unos paréntesis extras alrededor de \codigo{listaParametros + z}.
  \item \emph{Línea 4:} \codigo{2to3} es lo suficientemente inteligente como para convertir llamadas \codigo{apply()} complejas, incluidas las llamadas a función de módulos importados.
\end{enumerate}

\section{La función global \codigo{intern()}}

En Python 2, se puede llamar a la función \codigo{intern()} sobre una cadena de caracteres para internalizarla con el fin de optimizar su rendimiento. En Python 3, la función \codigo{intern()} se ha movido al módulo \codigo{sys}.

\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    & \codigo{intern(a, b, c)} & \codigo{sys.intern(a, b, c)} \\
    \hline
  \end{tabular}
\end{table}

\section{La sentencia \codigo{exec}}

Igual que se ha convertido la sentencia \codigo{print} en función en Python 3, se ha hecho lo mismo con la sentencia \codigo{exec}. La función \codigo{exec()} toma una cadena de caracteres que contiene cualquier código Python y lo ejecuta como si fuese una sentencia o expresión. \codigo{exec()} es como \codigo{eval()}, pero aún más poderoso y maligno. La función \codigo{eval()} solo puede evaluar una única expresión, pero \codigo{exec()} puede ejecutar múltiples sentencias, importar paquetes, declarar funciones ---esencialmente, ejecutar un programa Python entero, escrito en una cadena de caracteres.


\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1 & \codigo{exec cadenaEjecutable} & \codigo{exec(cadenaEjecutable)} \\
    2 & \codigo{exec cadenaEjec in espNombresGlobal} & \codigo{exec(cadenaEjec, espNombresGlobal)} \\
    3 & \codigo{exec cadenaEjec in espNombresGlobal,} & \codigo{exec(cadenaEjec, espNombresGlobal,} \\
    & \quad \codigo{espacioNombresLocal} & \quad \codigo{espacioNombresLocal)} \\
    \hline
  \end{tabular}
\end{table}


\begin{enumerate}
  \item \emph{Línea 1:} en su forma más simple, \codigo{2to3} simplemente envuelve entre paréntesis a la cadena de caracteres que contiene el código fuente.
  \item \emph{Línea 2:} la antigua sentencia \codigo{exec} pordía tomar un espacio de nombres, un espacio privado de elementos globales en el que el código fuente se ejecutaría. En Python 3, esto se hace pasando el espacio de nombres como segundo parámetro de la función \codigo{exec()}.
  \item \emph{Línea 3:} la anterior sentencia \codigo{exec} podía tomar como parámetro un espacio de nombres local (como las variables definidas dentro de una función). En Python 3, aún se puede hacer con la función \codigo{exec()}.
\end{enumerate}

\section{La sentencia \codigo{execfile}}

Como la anterior sentencia \codigo{exec}, la sentencia \codigo{execfile} sirve ejecuta el código escrito, esta vez, en un fichero. En Python 3 esta sentencia se ha eliminado. Si realmente necesitas leer un fichero Python y ejecutarlo (pero no deseas, simplemente, importarlo), puedes conseguirlo abriendo el fichero, leyendo su contenido, llamando a la función global \codigo{compile()} para forzar al interprete de Python a compilar el código, y luego llamar a la nueva función \codigo{exec()}.


\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
      & \codigo{execfile('nombre\_fichero'}) & \codigo{exec(compile(open('nombre\_fichero').read(),} \\
    & & \quad \codigo{'nombre\_fichero2', 'exec'))} \\
    \hline
  \end{tabular}
\end{table}

\section{Literales \codigo{repr} (comilla invertida)}

En Python 2, existe una sintaxis especial para envolver cualquier objeto en comillas invertidas (como \`{}x\`{}) para obtener una representación del objeto. En Python 3, no puedes utilizarlas; en su lugar, debes usar la función global \codigo{repr()}.


\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1  & \codigo{\`{}x\`{}} & \codigo{repr(x)} \\
    2  & \codigo{\`{}'PapayaWhip' + \`{}2\`{}\`{}} & \codigo{repr('PapayaWhip' + repr(2))} \\
    \hline
  \end{tabular}
\end{table}

\begin{enumerate}
  \item \emph{Línea 1:} recuerda, \codigo{x} puede ser cualquier cosa: una clase, una función, un módulo, un tipo de datos primitivo, etc. La función \codigo{repr()} funciona sobre cualquier cosa.
  \item \emph{Línea 2:} En Python 2, las comillas invertidas se pueden anidar, \codigo{2to3} es lo suficientemente inteligente para detectarlas y convertirlas en llamadas anidadas a \codigo{repr()}.
\end{enumerate}

\section{La sentencia \codigo{try \ldots except}}

La sintaxis para capturar excepciones ha cambiado ligeramente entre Python 2 y Python 3.


\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1  & \codigo{try:} & \codigo{try:} \\
       & \quad \codigo{import mymodule} & \quad \codigo{import mymodule} \\
       & \codigo{except ImportError, e} & \codigo{except ImportError as e:} \\
       & \quad \codigo{pass} & \quad \codigo{pass} \\
    & \\
    2  & \codigo{try:} & \codigo{try:} \\
       & \quad \codigo{import mymodule} & \quad \codigo{import mymodule} \\
       & \codigo{except (RuntimeError, ImportError), e} & \codigo{except (RuntimeError, ImportError) as e:} \\
       & \quad \codigo{pass} & \quad \codigo{pass} \\

    & \\
    3  & \codigo{try:} & \codigo{} \\
    & \quad \codigo{import mymodule} & \emph{no cambia} \\
       & \codigo{except ImportError:} & \codigo{} \\
       & \quad \codigo{pass} & \quad \codigo{} \\

    & \\
       4  & \codigo{try:} & \codigo{} \\
       & \quad \codigo{import mymodule} & \emph{no cambia} \\
       & \codigo{except:} & \codigo{} \\
       & \quad \codigo{pass} & \quad \codigo{} \\

    \hline
  \end{tabular}
\end{table}
\FloatBarrier

\begin{enumerate}
  \item \emph{Línea 1:} en lugar de una coma después del tipo de la excepción, Python 3 utiliza una palabra reservada nueva \codigo{as}.
  \item \emph{Línea 2:} la palabra reservada \codigo{as} también se usa en la captura de múltiples tipos de excepción de una vez.
  \item \emph{Línea 3:} si capturas una excepción pero te da igual acceder al objeto de la excepción, la sintaxis es idéntica en Python 2 y 3.
  \item \emph{Línea 4:} igualmente, si utilizas la sintaxis para capturar \emph{todos} los tipos de excepción posibles, la sintaxis es idéntica en Python 2 y 3.
\end{enumerate}

\cajaTextoAncho{Nunca deberías utilizar la captura por defecto de \emph{todos} los tipos de excepción cuando importes módulos (o en la mayoría de otras ocasiones). Al hacer esto, capturarás cosas como \codigo{KeyboardInterrupt} (que se dispara si el usuario pulsa \codigo{Ctrl-C} para interrumpir el programa) y que puede hacer más difícil depurar los errores.}

\section{La sentencia \codigo{raise}}

La sintaxis para elevar tus propias excepciones ha cambiado también ligeramente.


\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1  & \codigo{raise miExcepcion} & \emph{no cambia} \\
    2  & \codigo{raise miExcepcion, 'mensaje de error'} & \codigo{raise miExcepcion('mensaje de error')} \\
    3  & \codigo{raise miExcepcion, 'mensaje de error',} & \codigo{raise miExcepcion('mensaje de error').} \\
       & \codigo{traza)} & \codigo{with\_traceback(traza)} \\
    4  & \codigo{raise 'mensaje de error'} & \emph{no soportado} \\
    \hline
  \end{tabular}
\end{table}


\begin{enumerate}
  \item \emph{Línea 1:} en su forma más simple ---cuando se eleva una excepción sin incluir mensaje de error--- la sintaxis no ha cambiado.
  \item \emph{Línea 2:} la modificación de sintaxis se deja notar cuando quieres elevar una excepción con un mensaje de error personalizado. Python 2 separaba el tipo de excepción y el mensaje con una coma; Python 3 lo pasa como parámetro de la excepción.
  \item \emph{Línea 3:} Python 2 soportaba una sintaxis más compleja para elevar una excepción con una pila de trazabilidad a medida. En Python 3, para hacer esto, la sintaxis es diferente.
  \item \emph{Línea 4:} en Python 2, podías elevar una excepción sin introducir el tipo de la misma, solo el mensaje de error. En Python 3, esto no es posible. \codigo{2to3} te avisará de que no ha sido capaz de arreglarlo automáticamente.
\end{enumerate}

\section{El método \codigo{throw} en generadores}

En Python 2, los generadores disponen de un método \codigo{throw()}: al llamar a este método se eleva una excepción en el punto en el que el generador estuviera pausado, luego se devuelve el siguiente valor disponible (en \codigo{yield}). En Python 3, esta funcionalidad sigue existiendo con pequeños cambios.


\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1  & \codigo{unGenerador.throw(miExcepcion)} & \emph{no cambia} \\
    2  & \codigo{unGenerador.throw(miExcepcion, } & \codigo{unGenerador.throw(} \\
      & \quad \codigo{'mensaje de error')} & \quad \codigo{miExcepcion('mensaje de error'))} \\
    3  & \codigo{unGenerador.throw('mensaje de error')} & \emph{no soportado} \\
    \hline
  \end{tabular}
\end{table}
\FloatBarrier

\begin{enumerate}
  \item \emph{Línea 1:} en su forma más simple, un generador lanza una excepción sin un mensaje de error. En este caso, la sintaxis no cambia.
  \item \emph{Línea 2:} si el generador lanza una excepción con un mensaje de error, necesitas pasar la cadena de caracteres del mensaje como parámetro de la excepción que estás creando.
  \item \emph{Línea 3:} Python 2 también soportaba el lanzar una excepción solamente con el mensaje de error, sin indicar su tipo. En Python 3 esto no está permitido, \codigo{2to3} mostrará un aviso indicando que necesitas arreglar esto manualmente.
\end{enumerate}

\section{La función global \codigo{xrange()}}

En Python 2, había dos formas de obtener un rango de números: \codigo{range()}, que retornaba una lista; y \codigo{xrange()}, que retornaba un iterador. En Python 3, \codigo{range()} retorna un iterador, y \codigo{xrange()} no existe.


\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1  & \codigo{xrange(10)} & \codigo{range(10)} \\
    2  & \codigo{lista = range(10)} & \codigo{lista = list(range(10))} \\
    3  & \codigo{[i for i in xrange(10)]} & \codigo{[i for i in range(10)]} \\
    4  & \codigo{for i in range(10):} & \emph{no cambia} \\
    5  & \codigo{sum(range(10))} & \emph{no cambia} \\
    \hline
  \end{tabular}
\end{table}

\begin{enumerate}
  \item \emph{Línea 1:} en su forma más simple, \codigo{2to3} convierte \codigo{xrange()} en \codigo{range()}.
  \item \emph{Línea 2:} Si tu código Python 2 usa \codigo{range()}, \codigo{2to3} no sabe si necesitas una lista o un iterador; por ello, opta por lo seguro, que es envolver la función en una lista llamando a la función \codigo{list()}.
  \item \emph{Línea 3:} si la función \codigo{xrange()} se encontraba en una comprensión de lista, \codigo{2to3} es suficientemente inteligente como para no envolverla en una lista.
  \item \emph{Línea 4:} De forma similar, un bucle \codigo{for} funcionará igual de bien con un iterador. Por lo que no hay necesidad de cambiar nada en e este caso.
  \item \emph{Línea 5:} la función \codigo{sum()} también funciona con un iterador, por eso \codigo{2to3} no hace ningún cambio. Esto se aplica a \codigo{min()}, \codigo{max()}, \codigo{sum()}, \codigo{list()}, \codigo{tuple()}, \codigo{set()}, \codigo{sorted()}, \codigo{any()}, y \codigo{all()}.
\end{enumerate}


\section{Las funciones globales \codigo{raw\_input()} e \codigo{input()}}

Python 2 tiene dos funciones globales para pedir al usuario que introduzca datos en la línea de comandos. La primera se denomina \codigo{input()}, y espera que el usuario introduzca una expresión Python (y devuelve el resultado). La segunda, denominada \codigo{raw\_input()}, simplemente retorna lo que el usuario ha tecleado. Esto es confuso para principiantes. Python 3 redenomina \codigo{raw\_input()} a \codigo{input()}, para que funcione como todo el mundo imagina que debería.


\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1  & \codigo{raw\_input()} & \codigo{input()} \\
    2  & \codigo{raw\_input('prompt:')} & \codigo{input('prompt:')} \\
    3  & \codigo{input()} & \codigo{eval(input())} \\
    \hline
  \end{tabular}
\end{table}


\begin{enumerate}
  \item \emph{Línea 1:} en su forma más simple, \codigo{raw\_input()} pasa a ser \codigo{input()}.
  \item \emph{Línea 2:} en Python 2, la función \codigo{raw\_input()} podía pedir al usuario (con una cadena de caracteres) la entrada de datos mediante un ``prompt'' que se pasaba como parámetro. Esto se mantiene en Python 3 en la nueva función \codigo{input()}.
  \item \emph{Línea 3:} si realmente necesitas pedirle al usuario una expresión que luego debes evaluar, utiliza \codigo{input()} y pasa el resultado a la funicón \codigo{eval()}.
\end{enumerate}

\section{Los atributos de función \codigo{func\_*}}

En Python 2, el código dentro de las funcionas puede acceder a atributos de la propia función. En Python 3, estos atributos especiales se han redenominado por consistencia con otros atributos.


\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1  & \codigo{unaFuncion.func\_name} & \codigo{unaFuncion.\_\_name\_\_} \\
    2  & \codigo{unaFuncion.func\_doc} & \codigo{unaFuncion.\_\_doc\_\_} \\
    3  & \codigo{unaFuncion.func\_defaults} & \codigo{unaFuncion.\_\_defaults\_\_} \\
    4  & \codigo{unaFuncion.func\_dict} & \codigo{unaFuncion.\_\_dict\_\_} \\
    5  & \codigo{unaFuncion.func\_closure} & \codigo{unaFuncion.\_\_closure\_\_} \\
    6  & \codigo{unaFuncion.func\_globals} & \codigo{unaFuncion.\_\_globals\_\_} \\
    7  & \codigo{unaFuncion.func\_code} & \codigo{unaFuncion.\_\_code\_\_} \\
    \hline
  \end{tabular}
\end{table}
\FloatBarrier

\begin{enumerate}
  \item \emph{Línea 1:} el nombre de la función.
  \item \emph{Línea 2:} contiene el \codigo{docstring} definido para la función en el código fuente.
  \item \emph{Línea 3:} una tupla que contiene los valores por defecto de los parámetros, para aquellos que lo tengan.
  \item \emph{Línea 4:} es el espacio de nombres que soporta los atributos de la función.
  \item \emph{Línea 5:} es una tupla de celdas que contienen los enlaces (bindings) de las variables libres de la función.
  \item \emph{Línea 6:} es una referencia al espacio de nombres global del módulo en el que la función fue definida.
  \item \emph{Línea 7:} es un objeto de código que representa al cuerpo compilado de la función.
\end{enumerate}


\section{El método de E/S \codigo{xreadlines()}}

En Python 2, los objetos fichero tenían un método \codigo{xreadlines()} que devolvía un iterador que leía una línea cada vez. Era útil en bucles \codigo{for}, entre otros lugares. En realidad, era tan útil, que posteriores versiones añadieron esta capacidad de forma nativa a los propios objetos fichero.

En Python 3, la función \codigo{xreadlines()} ya no existe. \codigo{2to3} puede arreglar los casos más simples, pero otros requieren de intervención manual.

\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1  & \codigo{for linea in fich.xreadlines():} & \codigo{for linea in fich:} \\
    2  & \codigo{for linea in fich.xreadlines(5):} & \emph{no cambia (roto)} \\
    \hline
  \end{tabular}
\end{table}

\begin{enumerate}
  \item \emph{Línea 1:} si llamabas a \codigo{xreadlines()} sin parámetros, \codigo{2to3} lo convertirá al objeto fichero (sin necesidad de llamada extra).
  \item \emph{Línea 2:} si llamabas a \codigo{xreadlines()} pasándole el número de línea a leer cada vez, \codigo{2to3} no lo arreglará, y el código fallará con una excepción \codigo{AttributeError: '\_io.TextIOWrapper' object has no attribute 'xreadlines'}. Puedes cambiar manualmente \codigo{xreadlines()} a \codigo{readlines()} para que funcione en Python 3 (El método \codigo{readlines()} ahora devuelve un iterador, por lo que es tan eficiente como era \codigo{xreadlines()} en Python 2).
\end{enumerate}

\section{Funciones \codigo{lambda} con parámetros tupla}

En Python 2, podías definir una función \codigo{lambda} anónima que tomara varios parámetros definiendo la función para que recibiera una tupla con un número específico de elementos. Python 2 ``desempaqueta'' la tupla en los parámetros con nombre, que luego puedes referenciar (por nombre) en la propia función \codigo{lambda}. En Python 3, aún puedes pasar una tupla a una función \codigo{lambda}, pero el interprete de Python no desempaquetará los parámetros. En su lugar, necesitas referenciar cada uno de ellos mediante su posición en la tupla.


\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1  & \codigo{lambda (x,): x + f(x)} & \codigo{lambda x1: x1[0] + f(x1[0])} \\
    2  & \codigo{lambda (x, y): x + f(y)} & \codigo{lambda x\_y: x\_y[0] + f(x\_y[1])} \\
    3  & \codigo{lambda (x, (y,z)): x + y + z} & \codigo{lambda x\_y\_z: x\_y\_z[0] +} \\ 
       &  & \quad \codigo{x\_y\_z[1][0] + x\_y\_z[1][1]} \\
    4  & \codigo{lambda x, y, z: x + y + z} & \emph{no cambia} \\
    \hline
  \end{tabular}
\end{table}


\begin{enumerate}
  \item \emph{Línea 1:} si habías definido una función \codigo{lambda} que toma como parámetro una tupla con un único elemento, en Python 3, \codigo{2to3} lo convertirá en referencias al rimer elemento \codigo{x1[0]}. El nombre \codigo{x1} es autogenerado, y se basa en el nombre del parámetro de la tupla original.
  \item \emph{Línea 2:} una función \codigo{lambda} con una tupla de dos elementos \codigo{(x, y)} se convierte en \codigo{x\_y} con los parámetros en las posiciones \codigo{x\_y[0]} \codigo{x\_y[1]}
  \item \emph{Línea 3:} \codigo{2to3} puede manejar funciones \codigo{lambda} con tuplas anidadas como parámetros. El código resultate en Python 3 es poco legible.
  \item \emph{Línea 4:} puedes definir funciones \codigo{lambda} con varios parámetros que no sean tuplas; en este caso la sintaxis de Python 3 no cambia.
\end{enumerate}

\section{Atributos especiales de métodos}

En Python 2, los métodos de las clases pueden referenciar al objeto clase en el que están definidos, así como el objeto método en sí mismo. \codigo{im\_self} es el objeto instancia de la clase; \codigo{im\_func} es el objeto función (el propio método); \codigo{im\_class} es la clase de \codigo{im\_self}. En Python 3, estos atributos especiales de método se han redenominado para seguir las convenciones de otros atributos.


\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    & \codigo{instDeClase.MétDeClase.im\_func} & \codigo{instDeClase.MétDeClase.\_\_func\_\_} \\
         & \codigo{instDeClase.MétDeClase.im\_self} & \codigo{instDeClase.MétDeClase.\_\_self\_\_} \\
         & \codigo{instDeClase.MétDeClase.im\_class} & \codigo{instDeClase.MétDeClase.\_\_self\_\_.\_\_class\_\_} \\
    \hline
  \end{tabular}
\end{table}

\section{El método especial \codigo{\_\_nonzero\_\_}}

En Python 2, podrías construir tus propias clases que podían utilizarse en contextos booleanos. Por ejemplo, podrías instanciar un objeto de la clase y luego usar esta instancia como condición en una sentencia \codigo{if}. Para hacer esto debías definir un método especial \codigo{\_\_nonzero\_\_()} que debía devolver \codigo{True} o \codigo{False}, y que Python llamaba siempre que un objeto se utilizara en un contexto booleano. En Python 3, se ha cambiado el nombre del método a \codigo{\_\_bool\_\_()}.


\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1  & \codigo{class A:} & \codigo{class A:} \\
       &  \quad \codigo{def \_\_nonzero\_\_(self):} &   \quad\codigo{def \_\_bool\_\_(self):} \\
       & \quad\quad\codigo{pass} & \quad\quad\codigo{pass} \\
       & \\
    2  & \codigo{class A:} & \codigo{} \\
       & \quad \codigo{def \_\_nonzero\_\_(self, x, y):} & \emph{no cambia} \\
       & \quad\quad \codigo{pass} & \codigo{} \\
    \hline
  \end{tabular}
\end{table}


\begin{enumerate}
  \item \emph{Línea 1:} en lugar de \codigo{\_\_nonzero\_\_()}, Python 3 llama al método \codigo{\_\_bool\_\_()} cuando evalúa una objeto en un contexto booleano.
  \item \emph{Línea 2:} sin embargo, si tu código tiene un objeto \codigo{\_\_nonzero\_\_()} con argumentos adicionales a \codigo{self}, \codigo{2to3} asumirá que lo estabas usando para otro propósito y no hará ningún cambio en este método.
\end{enumerate}

\section{Literales octales}

Ha cambiado ligeramente:


\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
      & \codigo{x = 0755} & \codigo{x = 0o755} \\
    \hline
  \end{tabular}
\end{table}

\section{\codigo{sys.maxint}}

Debido a que los tipos long e int se integran en uno solo, la constante \codigo{sys.maxint} deja de ser precisa. Por ello se ha redenominado a \codigo{sys.maxsize}.

\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1  & \codigo{from sys import maxint} & \codigo{from sys import maxsize} \\
    2  & \codigo{unaFunción(sys.maxint)} & \codigo{unaFunción(sys.maxsize)} \\
    \hline
  \end{tabular}
\end{table}


\begin{enumerate}
  \item \emph{Línea 1:} \codigo{maxint} se convierte en \codigo{maxsize}.
  \item \emph{Línea 2:} Cualquier uso de \codigo{sys.maxint} se convierte en \codigo{sys.maxsize}.
\end{enumerate}

\section{La función global \codigo{callable()}}

En Python 2, podías comprobar con la función \codigo{callable()} si un objeto se podía ``llamar'' (como una función). En Python 3, esta función global se ha eliminado. Para comprobar si un objeto se puede llamar hay que comprobar la existencia del método especial \codigo{\_\_call\_\_()}.


\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1  & \codigo{callable(cualquierObjeto)} & \codigo{hasattr(cualquierObjeto, '\_\_call\_\_')} \\
    \hline
  \end{tabular}
\end{table}

\section{La función global \codigo{zip()}}

En Python 2, la función global \codigo{zip()} tomaba cualquier número de secuencias y devolvía una lista de tuplas. La primera tupla contenía el primer elemento de cada una de las secuencias que había recibido como parámetros; la segunda tupla, los segundos elementos de cada secuencia, y así sucesivamente. En Python 3, \codigo{zip()} devuelve un iterador en lugar de una lista.


\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1  & \codigo{zip(a, b, c)} & \codigo{list(zip(a, b, c))} \\
    2  & \codigo{d.join(zip(a, b, c))} & \emph{no cambia} \\
    \hline
  \end{tabular}
\end{table}


\begin{enumerate}
  \item \emph{Línea 1:} En su forma más simple, se conserva el anterior comportamiento con una llamada a \codigo{list()} que envuelva a \codigo{zip()}.
  \item \emph{Línea 2:} En contextos en los que ya se itera a través de los elementos de una secuencia (como la llamada a \codigo{join()}), \codigo{2to3} es lo suficientemente inteligente para detectar estos casos y no hacer cambios en el código.
\end{enumerate}

\section{La excepción \codigo{StandardError}}

En Python 2, \codigo{StandardError} era la clase base de todas las excepciones internas salvo \codigo{StopIteration}, \codigo{GeneratorExit}, \codigo{KeyboardInterrupt}, y \codigo{SystemExit}. En Python 3, \codigo{StandardError} ha sido eliminada; en su lugar se debe usar \codigo{Exception}.


\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
      & \codigo{x = StandardError()} & \codigo{x = Exception()} \\
      & \codigo{x = StandardError(a, b, c)} & \codigo{x = Exception(a, b, c)} \\
    \hline
  \end{tabular}
\end{table}

\section{Constantes del módulo \codigo{types}}

El módulo \codigo{types} contiene una variedad de constantes destinadas a ayudar a encontrar el tipo de un objeto. En Python 2, contenía constantes para todos los tipos primitivos como \codigo{dict} e \codigo{int}. En Python 3, se han eliminado estas constantes; basta con usar el propio nombre de los tipos.


\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
      & \codigo{types.UnicodeType} & \codigo{str} \\
      & \codigo{types.StringType} & \codigo{bytes} \\
      & \codigo{types.DictType} & \codigo{dict} \\
      & \codigo{types.IntType} & \codigo{int} \\
      & \codigo{types.LongType} & \codigo{int} \\
      & \codigo{types.ListType} & \codigo{list} \\
      & \codigo{types.NoneType} & \codigo{type(None)} \\
      & \codigo{types.BooleanType} & \codigo{bool} \\
      & \codigo{types.BufferType} & \codigo{memoryview} \\
      & \codigo{types.ClassType} & \codigo{type} \\
      & \codigo{types.ComplexType} & \codigo{complex} \\
      & \codigo{types.EllipsisType} & \codigo{type(Ellipsis)} \\
      & \codigo{types.FloatType} & \codigo{float} \\
      & \codigo{types.ObjectType} & \codigo{object} \\
      & \codigo{types.NotImplementedType} & \codigo{type(NotImplemented)} \\
      & \codigo{types.SliceType} & \codigo{slice} \\
      & \codigo{types.TupleType} & \codigo{tuple} \\
      & \codigo{types.TypeType} & \codigo{type} \\
      & \codigo{types.XRangeType} & \codigo{range} \\
    \hline
  \end{tabular}
\end{table}
\FloatBarrier

\cajaTextoAncho{\codigo{types.StringType} se mapea a \codigo{bytes} en lugar de a \codigo{str} porque en Python 2 ``string'' (no Unicode) realmente es una secuencia de bytes en una codificación de caracteres determinada.}

\section{La función global \codigo{isinstance()}}

La función \codigo{insinstance()} comprueba si un objeto es una instancia de una clase o tipo particular. En Python 2, puedes pasar una tupla de tipos: \codigo{isinstance()} devolverá \codigo{True} si el objeto es de alguno de los tipos de la tupla. En Python 3, aún puedes hacerlo, pero pasar el mismo tipo dos veces está deprecado.


\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
      & \codigo{isinstance(x (int, float, int))} & \codigo{isinstance(x, (int, float))} \\
    \hline
  \end{tabular}
\end{table}

\section{El tipo de datos \codigo{basestring}}

Python 2 tenía dos tipos de cadenas de caracteres: Unicode y no Unicode. Pero había también otro tipo: \codigo{basestring}. Era un tipo de datos abstracto, una superclase para ambos tipos: \codigo{str} y \codigo{unicode}. No se podía instanciar directamente, pero sí se podía pasar a la función global \codigo{isinstance()}. En Python 3, solamente existe un tipo de datos de cadenas de caracteres, por lo que \codigo{basestring} no tiene razón de existir.


\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
      & \codigo{isinstance(x, basestring)} & \codigo{isinstance(x, str)} \\
    \hline
  \end{tabular}
\end{table}

\section{El módulo \codigo{itertools}}

Python 2.3 introdujo el módulo \codigo{itertools}, que definía variantes de las funciones \codigo{zip()}, \codigo{map()}, y \codigo{filter()} que devolvían iteradores en lugar de listas. En Python 3, las funciones originales ya devuelven iteradores, por lo que estas funciones se han eliminado del módulo.


\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1  & \codigo{itertools.izip(a, b)} & \codigo{zip(a, b)} \\
    2  & \codigo{itertools.imap(a, b)} & \codigo{map(a, b)} \\
    3  & \codigo{itertools.ifilter(a, b)} & \codigo{filter(a, b)} \\
    4  & \codigo{from itertools import imap, izip, foo} & \codigo{from itertools import foo} \\
    \hline
  \end{tabular}
\end{table}


\begin{enumerate}
  \item \emph{Línea 1:} En lugar de \codigo{itertools.izip()}, utiliza \codigo{zip()}.
  \item \emph{Línea 2:} En lugar de \codigo{itertools.imap()}, utiliza \codigo{map()}.
  \item \emph{Línea 3:} En lugar de \codigo{itertools.ifilter()}, utiliza \codigo{filter()}.
  \item \emph{Línea 4:} El módulo \codigo{itertools} aún existe en Python 3, solamente le faltan las funciones que han migrado al espacio global de nombres. \codigo{2to3} es suficientemente inteligente para eliminar los \codigo{import} específicos que han dejado de existir, conservando los demás.
\end{enumerate}

\section{\codigo{sys.exc\_type}, \codigo{sys.exc\_value}, \codigo{sys.exc\_traceback}}

Python 2 tiene tres variables en el módulo \codigo{sys} que puedes acceder mientras se está manejando una excepción: \codigo{sys.exc\_type}, \codigo{sys.exc\_value}, \codigo{sys.exc\_traceback} (En realidad, se remontan a Python 1). Estas variables están deprecadas desde Python 1.5, en favor del uso de \codigo{sys.exc\_info()}, que es una función que retorna una tupla que contiene los tres valores. En Python 3, estas variables individuales por fin desaparecen; debes usar obligatoriamente la función.


\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
      & \codigo{sys.exc\_type} & \codigo{sys.exc\_info()[0]} \\
      & \codigo{sys.exc\_value} & \codigo{sys.exc\_info()[1]} \\
      & \codigo{sys.exc\_traceback} & \codigo{sys.exc\_info()[2]} \\
    \hline
  \end{tabular}
\end{table}

\section{Listas por comprensión a partir de tuplas}

En Python 2, si quieres codificar una lista por comprensión que a partir de una tupla, no necesitas poner paréntesis sobre los valores de la tupla. En Python 3, es necesario explicitarlos.


\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
       & \codigo{[i for i in 1, 2]} & \codigo{[i for i in (1, 2)]} \\
    \hline
  \end{tabular}
\end{table}

\section{La función \codigo{os.getcwdu()}}

Python 2 tiene una función denominada \codigo{os.getcwd()}, que devuelve el directorio de trabajo actual como una cadena de caracteres (no Unicode). Puesto que los sistemas de ficheros modernos pueden manejar nombres en cualquier codificación de caracteres, Python 2.3 introdujo la función \codigo{os.getcwdu()} que devuelve el directorio de trabajo actual codificado en una cadena de caracteres Unicode. En Python 3, solamente existe un tipo de cadena de caracteres (es Unicode), por eso solamente existe \codigo{os.getcwd()}.


\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
       & \codigo{os.getcwdu()} & \codigo{os.getcwd()} \\
    \hline
  \end{tabular}
\end{table}

\section{Metaclases}

En Python 2, podías crear metaclases, bien definiendo el parámetros \codigo{metaclass} en la declaración de la clase, o bien, definiendo un atributo especial de clase \codigo{\_\_metaclass\_\_}. En Python 3, el atributo de clase ha sido eliminado.


\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    1  & \codigo{class C(metaclass=PapayaMeta):} & \emph{no cambia} \\
      & \quad \codigo{pass} & \codigo{} \\
      & \\
    2  & \codigo{class Whip:} & \codigo{class Whip(metaclass=PapayaMeta):} \\
      & \quad \codigo{\_\_metaclass\_\_} & \quad \codigo{pass} \\
      & \\
      3 & \codigo{class C(Whipper, Beater):} & \codigo{class C(Whipper, Beater, metaclass=PapayaMeta):} \\
      4 & \quad \codigo{\_\_metaclass\_\_ = PapayaMeta} & \quad \codigo{pass} \\
    \hline
  \end{tabular}
\end{table}
\FloatBarrier

\begin{enumerate}
  \item \emph{Línea 1:} Declarar la metaclase en la declaración de clase funcinoa tanto en Python 2, como en Python 3.
  \item \emph{Línea 2:} Declarar la metaclase en un atributo de clase funcionaba en Python 2, pero no en Python 3.
  \item \emph{Línea 3:} \codigo{2to3} es lo suficientemente inteligente como para construir una declaración de clase válida, incluso si la clase hereda de otras clases.
\end{enumerate}

\section{Temas de estilo}

El resto de los ``arreglos'' listados aquí, realmente no lo son. Son cosas que \codigo{2to3} cambia como mejora de estilo. Funcionan igual ambas soluciones tanto en Python 2 como en Python 3, pero los desarrolladores tienen interés en que el código fuente de Python sea lo más homogéneo posible en cuanto a estilo. Por ello, existe una \\href{http://www.python.org/dev/peps/pep-0008/}{Guía oficial de estilo de Python} que describe ---con todo lujo de detalles--- toda clase de reglas de escritura que, seguramente, no te interesan.

\subsection{Literales \codigo{set()}}

En Python 2, la única forma de definir un conjunto con literales en el código es llamar a \codigo{set(unaSecuencia)}. Esto sigue funcionando en Python 3, pero una forma más clara de hacerlo es utilizar la nueva notación de literal de conjuntos: las llaves. Esto sirve para todos los conjuntos, excepto para los vacíos, ya que los diccionarios también utilizan las llaves, y \codigo{\{\}} es el conjunto vacío.

\cajaTextoAncho{\codigo{2to3}, por defecto, no arregla literales \codigo{set()}. Para activar esta modificación, debes especificar \codigo{-f set\_literal} en la línea de comando de \codigo{2to3}.}


\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
    & \codigo{set([1, 2, 3])} & \codigo{\{1, 2, 3\}} \\
    & \codigo{set((1, 2, 3))} & \codigo{\{1, 2, 3\}} \\
    & \codigo{[i for i in unaSecuencia]} & \codigo{\{i for in in unaSecuencia\}} \\
    \hline
  \end{tabular}
\end{table}

\subsection{La función global \codigo{buffer()}}

Los objetos Python implementados en C pueden exportar un ``interfaz de buffer'', que permite al código Python leer y escribir directamente en los bloques de memoria del objeto. En Python 3, \codigo{buffer()} se ha redenominado a \codigo{memoryview()} (Es más complicado que esto, pero puedes ignorar las diferencias).

\cajaTextoAncho{Para que \codigo{2to3} aplique este cambio hay que especificar el parámetro \codigo{-f buffer} en la línea de comando.}


\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
      & \codigo{x = buffer(y)} & \codigo{x = memoryview(y)} \\
    \hline
  \end{tabular}
\end{table}

\subsection{Espacios en blanco alrededor de comas}

A pesar de ser draconiano sobre el uso del espacio en blanco para la indentación, Python es bastante liberal sobre su uso en otras areas. En listas, tuplas, conjuntos y diccionaros, el espacio en blanco puede aparecer antes y después de las comas sin que ello provoque error. Sin embargo, la recomendación de la guía de estilo es que las comas no deben tener espacios en blanco delante de ellas y deben ir seguidas por uno. Aunque se trata de un tema puramente estético, \codigo{2to2} puede arreglarlo por ti.

\cajaTextoAncho{Para habilitar esta opción debes especificar el parámetro \codigo{-f wscomma} en la línea de comando de \codigo{2to3}}


\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
      & \codigo{a ,b} & \codigo{a, b} \\
      & \codigo{\{a :b\}} & \codigo{\{a: b\}} \\
    \hline
  \end{tabular}
\end{table}

\subsection{Idiomatismos habituales}

Hay un cierto número de idiomatismos que toda la comunidad Python usa. Algunos, como el bucle \codigo{while 1:}, provienen de Python 1 (Python no tuvo tipo booleano hasta la versión 2.3, así que los desarrolladores usaban 1 y 0 en su lugar). Los programadores actuales de Python deberían entrenar sus cerebros para usar las versiones modernas de estos idiomatismos.

\cajaTextoAncho{Para habilitar esta opción se debe especificar \codigo{-f idioms} en la línea de comando de \codigo{2to3}.}


\begin{table}[htp]
  \centering
  \begin{tabular}{cll}
    \hline
    Línea & Python 2 & Python 3 \\
    \hline
      & \codigo{while 1:} & \codigo{while True:} \\
      & \quad\codigo{hacerCosas()} & \quad\codigo{hacerCosas()} \\
      &  \\
      & \codigo{type(x) == T } & \codigo{isinstance(x, T)} \\
      & \codigo{type(x) is T} & \codigo{isinstance(x, T)} \\
      & \\
      & \codigo{unaLista = list(unaSecuencia)} & \codigo{unaLista = sorted(unaSecuencia)} \\
      & \codigo{unaLista.sort()} & \codigo{hacerCosas(unaLista)} \\
      & \codigo{hacerCosas(unaLista)} & \codigo{} \\
    \hline
  \end{tabular}
\end{table}

